# 判断完全树

## 解法

基本思路就是基于队列，先让根节点入队，然后队列里节点依次出队，每一个节点出队时让其左右子节点入队。

### 一种空间复杂度过于大的解法

这种解法是将所有子节点包括空节点都入队，然后若队列中空节点之后有非空节点，则不是完全树。  
问题在于对于完全树，每次都将把队列填满（后面全是空节点）之后才出循环，才能判断为正确，所以会消耗掉远大于节点数 N 的空间。

### 一种较优的解法

即对每个节点，赋值给它在完全树中的对应编号（2*n or 2*n+1），空节点不入队，这样当遍历完所有节点后判断队尾的编号与节点个数是否相等即可。  
我的代码写的二叉树类有点蠢...需要两个元素，一个表示节点编号，一个表示在完全树中的编号，所以使用了`std::pair<int,int>`

### 如果不用类

违背题目要求（使用二叉树类）的话直接使用数组简便不少。